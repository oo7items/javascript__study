<!-- 因此，我们了解了 AJAX 和 API 是什么。 我们已经使用了一堆异步代码 我们学习了所有关于承诺的知识。 但缺少的是最终了解所有它确实在 JavaScript 的幕后工作。 让我们来了解一下。 首先让我们快速回顾一下 JavaScript 运行时 我们在课程中谈到的方式， 只是为了确保本讲座的其余部分将使 感觉你。
   因此，JavaScript 运行时基本上是一个容器 其中包括所有不同的部分 这是执行 JavaScript 代码所必需的。 现在，每个 JavaScript 运行时的核心都是引擎。 所以，这是实际执行代码的地方 以及对象存储在内存中的位置。 所以，这两件事发生在调用堆栈中 并在堆中。
   
   现在，重要的是要注意 JavaScript 只有一种执行威胁。 所以它一次只能做一件事。 绝对不会发生多任务处理 在 JavaScript 本身中。 现在，Java 等其他语言可以执行多个片段 代码，但不是 JavaScript。 
   
   但无论如何，接下来我们有 Web API 环境。 这些是提供给引擎的一些 API， 但实际上不属于 JavaScript 语言本身。 所以，这就像 DOM 计时器 fetch API、geolocation API 等等。
   
   接下来是回调队列 这是一个包含所有准备好的数据结构 要执行的回调函数 到一些已经发生的事件。 (最后，每当调用堆栈为空时 事件循环从回调队列中获取回调 并将它们放入调用堆栈，以便它们可以被执行)。 所以事件循环是必不可少的 使异步行为成为可能的部分 在 JavaScript 中。
   
   这就是为什么我们可以拥有一个 JavaScript 中的非阻塞并发模型。 并发模型只是语言处理的方式 多件事情同时发生。 但是现在这怎么办 非阻塞并发真的有效吗？ 为什么事件循环如此重要？ 好吧，让我们来了解一下。 让我们在这里关注运行时的基本部分。 
   
   所以，这就是 Web API 事件循环的调用堆栈 并回调队列。 所以，如你所知，到目前为止，已经构建了一个 JavaScript 引擎 围绕单一威胁的想法。 但是如果引擎中只有一个执行线程 那么如何执行异步代码 以非阻塞方式？ 
   嗯，这实际上是一个大问题 我们将在这个视频中回答。 所以，
   基本上你会学到 JavaScript 并发模型是如何工作的 在幕后，使用所有部分 您已经知道的 JavaScript 运行时。 和往常一样，我们将通过查看来做到这一点 在一个真实的代码示例中。那么，让我们来看看代码行 按行，我会在我们进行时不断更新调用堆栈， 但是，您已经知道如何调用堆栈。 所以你最好更专注 在
   代码和 Web API 和回调队列上。 好的，
   
   但现在让我们从选择这个图像元素开始。 然后在下一行 我们将该图像的源属性设置为 dog.jpg。 正如我们之前了解到的，现在将开始加载 此图像在后台异步。 但
   
   这一次我们真的可以理解 那个神秘的背景究竟是什么。 所以，正如您已经知道与 DOM 相关的一切 实际上并不是 JavaScript 的一部分，而是 Web API 的一部分。 所以它在一个 web APIs 环境中 与 DOM 相关的异步任务将运行。 
   
   事实上，对于定时器 AJAX 调用也是如此 以及所有其他异步任务。 所以，同样，这些异步任务都会运行 在浏览器的 Web API 环境中。 现在，如果图像将以同步方式加载 它会在调用堆栈中这样做 阻止其余代码的执行。 但是，正如我们已经了解到的，那将是可怕的。 
   
   这就是为什么在 JavaScript 中加载图像是异步的。 所以它不会发生在调用堆栈中。 所以，不在执行的主线程中， 但实际上在 Web API 环境中 正如我之前提到的。 
   
   现在，如果我们想在图像之后做一些事情 已完成加载， 然后我们需要监听load事件。 这正是我们在下一行代码中所做的。 所以，在这里我们附加一个事件监听器 到该图像的加载事件 并像往常一样传递一个回调函数。 
   
   在实践中，这意味着注册这个回调 在 Web API 环境中， 正是图像加载的位置。 并回调将留在那里 直到发出 load 事件。 
   
   所以，我们在这里处理异步行为 就像我们之前学到的那样带有回调， 但无论如何，让我们回到代码。 因此，在下一行中，我们使用 AJAX 调用 获取 API。 和往常一样，异步获取操作会发生 在 Web API 环境中。 再一次，那是因为否则我们会阻塞 调用堆栈并在我们的应用程序中造成巨大的滞后。 
   
   最后，我们
   
   对返回的承诺使用 then 方法 通过 fetch 函数。 这也将注册一个回调 在 Web API 环境中，以便我们可以做出反应 到承诺的未来解决价值。 
     
   所以这个回调与一个promise相关联 即从 API 获取数据。 这在以后会很重要。 所以，有了这个，我们现在已经执行了所有 顶级代码)。 
   
   所以，所有不在任何回调函数中的代码 以异步方式。 我们还在后台加载图像 以及从 API 获取的一些数据。 所以现在是时候让它变得非常有趣了。 假设图像已完成加载 因此加载事件会在该图像上发出。 接下来发生什么， 是放了这个事件的回调 进入回调队列。 并且回调队列基本上是一个有序列表 所有回调函数中 排队执行。 你可以想到这个回调队列， 作为你会写的待办事项清单 为您自己完成您必须完成的所有任务。 所以，回调队列也是一类待办事项， 但是对于调用堆栈最终将执行的任务 必须完成。 现在，在这个例子中，没有其他回调 在队列中，但当然可能有。 所以，如果已经有其他回调等待 一致，那么这个新的回调当然会直接进行 到队列的末尾。
   
   它会耐心地坐在那里轮到它 最后运行。 这实际上具有重大意义。 (因此，假设您将计时器设置为 5 秒。 所以五秒钟后，计时器的回调将被放置 在回调队列上，对。 假设已经有其他回调在等待。 让我们也说它花了一秒钟 运行所有这些回调。 然后，在这种情况下，您的计时器回调只会运行 六秒后而不是五秒后。 所以，这六秒就是过去的五秒 对于计时器，加上它花费的一秒 运行已经在等待的所有其他回调 在你的计时器前排队。 所以，这意味着计时器的持续时间 您定义的不是保证。 唯一的保证是定时器回调 不会在五秒前运行， 但它可能会在五秒钟过去后运行)。 


   所以，这一切都取决于回调队列的状态。 还有另一个我们将要了解的队列 在一秒钟内。现在，(还有一件很重要的事情要在这里提及 是回调队列还包含即将到来的回调 来自 DOM 事件，如点击或按键等。 现在，我们之前了解到 DOM 事件并不是真的 异步行为，但他们仍然使用 回调队列运行其附加的回调。 因此，如果单击发生在带有 addEventListener 的按钮上 那么将会发生的事情就像我在这里说明的那样 与异步加载事件)。
   
   但无论如何现在是时候最终了解 事件循环。 所以，这就是事件循环所做的。 (它查看调用堆栈并确定是否 它是否为空。 当然，除了全球背景， 那么如果堆栈确实是空的 这意味着当前没有正在执行的代码 然后它将从回调队列中获取第一个回调 并将其放在调用堆栈中，两个将被执行。 这称为事件循环滴答。)
    所以每次事件循环都会有一个回调 从回调队列。 我们说有一个事件循环滴答。 所以，正如我们在这里看到的，事件循环 有着极其重要的任务 调用堆栈之间的协调 和回调队列中的回调。
    
    所以，事件循环基本上由谁来决定 当每个回调被执行时。 我们也可以说事件循环做了编排 整个 JavaScript 运行时。 从整个解释中可以清楚地看出另一件事 是 JavaScript 语言本身实际上具有 没有时间感。 那是因为一切都是异步的 不会发生在引擎中。 
    
    管理所有异步行为的是运行时。 由事件循环决定 接下来将执行哪些代码。 但是引擎本身只是简单地执行 它给出的任何代码。 好的，所以，这当然有很多东西要考虑。 因此，让我们尝试回顾一下这里发生的事情。 因此，图像开始异步加载 在 Web API 环境中 而不是在调用堆栈中，对。 然后我们使用 addEventListener 来附加 图像加载事件的回调函数。 而这个回调基本上还是异步代码 这是我们推迟到未来的代码 因为我们只想执行一次图像 已加载。 与此同时，其余的代码继续运行。 (现在addEventListener没有直接放回调 在回调队列中)。 它只是注册了回调，然后一直等待 在 Web API 环境中，直到加载事件 被解雇了。 只有这样，环境才将呼叫放回队列中。 然后在队列中回调一直在等待 让事件循环把它捡起来 并将其放在调用堆栈中。 一旦回调排在第一位，这就会发生 并且调用堆栈是空的。 而且，实际上就是这样。 所以，这一切都发生了，图像不必加载 在调用堆栈中，但在后台 以非阻塞方式。 因此，简而言之，Web API 环境， 回调队列 和事件循环一起，使它成为可能 异步代码可以以非阻塞方式执行 即使引擎中只有一个执行线程。 哇，已经明白了很多， 但我们还没有完成。因为我们还得获取 fetch 函数 在后台从 AJAX 调用中获取数据。 这基本上是在承诺的情况下发生的。 记住，现在有了 promises，事情就稍微变好了 不同的方式，这就是为什么我包含这个承诺示例 以及。 所以，假设数据现在终于到达了。 这样抓取就完成了。 现在，与承诺相关的回调 就像我们注册的这个 承诺然后方法。 实际上不要进入回调队列。 所以，我们还有这个回调吗？ 来自承诺的不会被移动到 回调队列。 相反，promise 的回调有一个特殊的队列 对于他们自己，这就是所谓的微任务队列。 现在，微任务队列的特别之处在于 它基本上优先于回调队列。 因此，在事件循环滴答结束时， 所以在回调之后 从回调队列中，事件循环将检查 如果微任务队列中有任何回调。 如果有，它将运行所有这些 在它运行更多回调之前 来自常规回调队列。 而且，顺便说一下，我们称这些回调 来自承诺微任务。 因此名称微任务队列。 实际上还有其他微任务 但这在这里无关紧要。 回到我们的例子， 目前，我们确实有一个微任务坐 在微任务队列中，调用栈也是空的。 因此事件循环现在将接受这个回调 并将其放入调用堆栈中，就像它所做的那样 来自回调队列的回调。 回调队列是否为空并不重要。 所以，这会以完全相同的方式工作 即使回调队列中有一些回调。 再一次，那是因为微任务总是具有优先权。 在实践中，这意味着微任务基本上可以 在所有其他常规回调之前排队。 现在，如果一个微任务添加了一个新的微任务 然后那个新的微任务也被执行 在回调队列中的任何回调之前。 这意味着微任务队列 基本上可以使回调队列挨饿。 因为如果我们不断添加越来越多的微任务， 那么回调队列中的回调永远无法执行。 现在，这通常不是问题 但无论如何我只想在这里提到这种可能性， 谁知道这可能是一个面试问题 总有一天为了你。 如果是这样，你现在就知道答案了。 但无论如何，正如你希望看到的那样 使用常规回调运行异步代码 来自 promise 的微任务非常相似。 唯一的区别是他们进入不同的队列 并且事件循环给予微任务优先权 通过常规回调。 好了，终于到了。 这就是你需要知道的一切 异步 JavaScript 确实在幕后工作。 我相信这些知识将会是 对您非常有帮助和价值。 因为你会更有信心写作 现在异步代码。而且你会回答任何面试问题 关于异步 JavaScript。 实际上很多 JavaScript 开发人员不知道 关于这个的任何事情。 所以，我相信这些知识会让你 进入前 10% 甚至前 5% 的 JavaScript 开发人员。 这本身就很棒，对吧。 但无论如何，让我们在这里没有结束 并在实践中尝试一些这些东西， -->
