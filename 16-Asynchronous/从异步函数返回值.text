这一点， 我们有一个很好的主意 如何使用 async/await，对吗？ 但是，还缺少一件重要的事情。 所以现在，它可能仍然有点不清楚 异步函数实际上是什么以及它是如何工作的。 现在让我们解决这个问题。 所以为了更好地理解， 这里实际发生了什么。 让我们开始在这里添加更多的 console.logs。 所以让我们说，会得到位置。 然后在这里的第二个，我们会说， 完成定位。 如果我们在这里检查结果，现在， 我希望你已经知道 这里日志的顺序是什么。 所以让我们看看。 确实如此， 我们立即得到第一个日志，然后是第二个。 当然只有在那之后 我们从异步函数中获取所有日志。 又是这样， 那是因为这是一个异步函数 在后台运行。 所以 JavaScript 立即继续前进 到下一行。 现在，如果这确实是一个常规函数 在那个常规函数中会有一个 console.log， 那么当然，这会出现在这里一到二之间。 对？好吧，让我们在这里称这三个，实际上。 所以它会出现在一到三之间， 但在这种情况下，它是一个异步函数， 所以它在后台运行 直到结果出来 好的。 但是现在假设我们想要返回一些数据 从这个功能，好吗？ 所以让我们首先在这里摆脱所有这些 console.logs。 把这一切放在一起更好一点。 所以最后在这里让我们说我们想回来 一个类似于我们之前基于地理编码数据的字符串。 这样数据就在 dataGeo 中 所以让我们说你在 数据地理城市 然后很快国家也在这里。 所以我们在这里返回这个字符串 所以假设我们现在想要得到， 当然，这里的数据。 所以现在，让我们假装 这只是一个常规函数 然后我们会这样做， 我们将简单地定义一个变量。然后，我们将存储返回的值。 然后在这里，我们可以看看， 但你认为在这种情况下会发生什么？ 走着瞧。 所以这里记录到控制台的第二件事 这是诺言吗。 还记得那个时候， 当我们第一次开始使用 async/await 时， 我告诉过你异步函数总是返回一个承诺。 这就是证明。 如果我们考虑一下， 那么在这里我们得到一个承诺实际上是有道理的 而不是我们想要获得的价值。 所以这里的字符串，对吧？ 原因是在代码的这一点上， JavaScript 根本无法知道 这里有一个我们想要的字符串 因为函数还在运行， 但它也没有阻止代码在这里。 (因此，再次，在这一点上， JavaScript 无法知道 这个函数会返回什么。 因此，该函数确实返回的所有内容 是一个承诺。)( 现在我们从异步函数返回的值， 再说一次，这是这里的字符串 将成为承诺的实现价值 由函数返回。 所以理解这一点很重要。 再一次，我们在这里看到的这个承诺， 该承诺的实现价值 将是这里的字符串， 因为那是我们返回的值 从异步函数 而至少如果这里没有错误发生 在函数中， 但现在，让我们再次假设这里的成功。 所以既然我们知道这里会返回一个承诺， 我们也知道如何才能真正获得我们想要的数据。 所以我们需要做的不是这里 很简单，我在哪里， 让我们注释掉这两个， 所以这将是我们的承诺。然后就像以前一样 我们可以使用 then 方法来获取已完成的值 的承诺。 我们现在就称它为一个城市。) 好的？ 所以我们使用完全相同的变量名 就像我们在这里所做的那样 但当然这里的这个没有用， 但在这里它会起作用。 因为再一次，在 then 处理程序中， 这个参数将被传递到回调函数中 将成为承诺的结果值。 还有一次， 这是这里返回的字符串 来自异步函数。 现在让我们看看会发生什么。 让我们拭目以待。 现在我们得到了我们的结果，您在葡萄牙的奥良。 所以有了这个， 我们基本上成功地返回了一个值 从函数。 现在我们将能够做得更好一点， 但现在让我们考虑一下错误。 因此，如果此 try 块中出现任何错误， 那么永远不会到达这里的返回 因为代码会立即跳转 到了 catch 块，对吧？ 所以让我们试着在这里创建一些错误。 我就在这里换一个 所以现在什么都行不通， 所以让我们等待吧。 所以确实，现在我们有一个错误。 现在我们从第 5、4、3 行得到 undefined。 就是这个。 所以现在确实没有从函数返回任何内容， 我们得到未定义。 现在有趣的是日志仍然有效。 这个console.log在这里， 现在在这里记录未定义的日志仍在运行， 这意味着这个回调函数仍在运行， 这意味着调用了 then 方法， 这反过来意味着这里的承诺 实际上是应验了，并没有被拒绝。 所以即使在 async 函数中有错误， 异步函数返回的承诺 还是实现了，没有被拒绝吧？ 事实上，如果我们在这里添加一个 catch 处理程序， 那么让我们看看会发生什么。 所以控制台错误， 错误信息， 那么我们的表情符号在这里。 实际上，让我们在这里添加两个。 所以顺序是一，二，三， 让我们在这里做同样的事情。 好的？ 所以我们仍然应该从这里得到错误 我们确实做到了， 但仍然是这里执行的回调。 所以这就是为什么我们得到两个 undefined 而不是 catch 块的原因。 又是这样， 这意味着即使有错误 在异步函数中， 它返回的承诺仍然兑现。问题，也希望我们能够在这个假想这个错误，如果我们这个错误的话，那么就可以把那个嘴喊出来该错误。因此，我们将手动承诺是从异步函数返回的原因，所以拒绝从函数现在返回的承诺。在这里可以接受错误并再次向我们抛出它。现在我们在这里遇到了与这里相同的错误。因此，再次，无法读取未定义的属性标志在这里也一样。解决方案 那个问题，好吗？现在终于，如果我们想修复而不是错误，但事实上，有三个是在两个之前出现的，那我们怎么做呢？最后，对吗？因为最后，你自己已经知道了，总会被处决。 三个三个，好吗？所以现在我们只得到一个，那么我们应该得到两个错误我们是三号。真的，如果现在这里从删除错误，然后一，二，三，希望的那样，好吗？所以我承认可能有点困惑，但部分我希望你明白这一切的原因。得，但在我看来，这里还是有问题。旧的以及这里处理的新方式，都在同一个代码中。这是我个人不喜欢的东西。所以我更喜欢总是只使用异步函数，我们不需要混合它们现在让他们继续转换为。 async/await。这就是我们接下来要做的。 现在如果我们可以简单地使用 await 那就太好了 没有异步功能， 但这并不奏效，至少目前是这样， 因为实际上有一个提案在进行中 实现这一目标，但就目前而言， await 只能在异步函数中使用。 然而，我们真的不想要一个新的完整功能， 所以我们可以使用 IIFE。 所以记得从前的 IIFE， 它们是立即调用的函数表达式。 请记住，这就是我们创建一个的方式。 所以我们写函数 那么这里是函数体， 然后最后我们简单地调用它。 所以当然我们也可以很容易地创建 异步 IIFE也是如此， 好的？ 实际上这个模式在这里 是 IIFE 的最后剩余案例之一，好吗？ 现在我真的想离开这个转换 将异步功能作为一个小挑战。 所以现在请暂停视频 花一两分钟 并在这里自己编写代码。 好的。 所以让我们从 try catch 块开始。 所以试试catch，在这里我们可以访问错误 然后让我们立即做这部分。 然后在这里我们可以简单地等待 whereAmI 承诺， 好的？ 然后我们要做的就是存储这个结果 进入城市变量，然后将其记录到控制台。 就这样， 现在终于，这里的最后一部分， 我们可以简单地把它放在 try catch 块之外。 所以无论如何它总是会被执行。 好的？ 所以让我们评论这个 我们应该得到完全相同的结果 让我们拭目以待。 现在我们开始。很好。 我们设法进行了转换 现在一切都在使用 async/await。 这样就好多了。 现在我们知道如何基本上返回数据 来自异步函数 以及如何正确接收和处理返回的数据。 对？ 而在现实生活中， 这是一直发生的事情。 所以我们有异步函数是很常见的 调用其他异步函数 并返回它们之间的值。 这就是我向你们展示这一切的原因。 确保您真正正确理解 异步函数如何在幕后工作。