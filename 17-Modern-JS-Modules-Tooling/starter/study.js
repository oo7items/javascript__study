/*
  开发步骤
    1. 当前我们构建应用程序时, 我们不只是将所有代码写入一个大脚本, 将脚本按原样发送到浏览器, 并收工
    2. 现在我们构建JavaScript应用程序的方式, 我们把项目分成多个模块, 并且这些模板可以在它们之间共享数据, 并使我们的代码更有条理和维护
    3. 关于模块可以包含第三方模块, 进入我们自己的代码，并且有数以千计的开源模块, 我们也称之为包, 开发人员在NPM库上共享, 我们可以在自己的代码中免费使用这些包(例如：React或jQuery)
    4. 所有这些包都可以通过 NPM 获得. 现在 NPM 代表节点包管理器, 因为它最初是一起开发的 使用 Node.js 和 4Node.js. NPM 已经确立了自己的地位作为去存储库适用于各种包装在现代 JavaScript 开发中. 
    5. 现在, 为了实际下载并使用和共享包, 我们使用安装在我们电脑上的 NPM 软件. 这只是一个简单的命令行界面 这使我们能够做到这一切. 所以基本上 NPM 既是存储库在哪些包中存在以及我们使用的程序在我们的计算机上安装和管理这些软件包. 所以假设我们已经完成了我们的项目代码的编写. 所以我们把它分成了多个模块 我们还包含了一些第三方模块
  构建过程
    1. 构建了一个大的最终JavaScript包, 这是我们最终的文件, 我们将部署到我们web服务器进行生产, 所以基本上它时JavaScript文件, 这将被发送到生产中的浏览器, 生产意味着应用被现实世界中的真实用户使用, 构建过程是非常复杂的, 这里保持简单, 并且只包括两个步骤
    2. 首先, 我们将捆绑所有模块, 合并成一个大文件, 这是一个复杂的过程, 我们可以消除未使用的代码并压缩或编码(这一步非常重要, 为什么？)
      a) 旧浏览器根本不支持模块, 因此无法执行模块中的代码通过任何较旧的浏览器, 其次，它的性能也更好向浏览器发送更少的文件，这也有好处捆绑步骤压缩了我们的代码。 
      b) 无论如何, 第二步, 我们做一些叫做transpiling 和 polyfilling的事情, 这基本上是要转换所有现代JavaScript语法和功能回到旧ES5语法, 这样即使是旧的浏览器也能理解, 我们的代码没有破坏. 这通常是使用Babel工具完成
    3. 经过两个步骤, 我们最终得到了最终的JavaScript包, 准备部署在服务器上生产
    1. 我们使用特殊工具来实现这个构建过程适合我们, 以及最常见的可用构建工具, 可能是webpack和Parcel, 这些被称为JavaScript打包器, 顾名思义, 他们拿走了我们的原始代码, 并将其转换为JavaScript包, 现在webpack是比较流行的, 但设置它可能非常困难和混乱, 那是因为有很多东西, 我们需要手动设置以使其正常工作
    2. Parcel是一个零配置打包器, 开箱即用, 所以在这个打包器中, 我们不必编写任何设置代码, 这是
*/

/****************** JavaScript 模块概述 */
/*
  1. 深入地讨论模块, 并了解他们如何在幕后工作, 所以本质上, 一个模块是一段可重用的代码, 封装了实现细节, 我们项目的某个部分, 现在听起来有点像一个函数, 甚至一个班级, 但不同的是一个模块, 通常是一个独立的文件, 但通常我们想到一个模块时, 我们想到了一个单独的文件
  2. 一个模块总是包含一些代码, 但它也可以有导入和导出, 所以对于出口, 顾名思义, 我们可以从模块中导出值, 例如, 简单的值甚至整个函数, 以及我们从模块中导出的任何内容, 称为公共API, 供其他代码使用
  3. 这个公共API实际上被消耗了通过将值导入模块, 所以就像我们可以导出值一样, 在模块中, 我们通常也可以导入值, 来自其他模块, 以及我们从中导入的这些其他模块, 然后称为依赖项, 导入模块, 因为死代码在模块中, 如果没有代码, dead 将无法导入, 它是从外部模块导入的, 对吗？
  4. 我们刚刚描述的整个逻辑适用于所有模块在所有编程语言中, 所以这不仅仅针对JavaScript,实际上, 模块时开发人员的一种模式, 几十年来一直在所有语言中使用
  5. 我们当然可以编写没有模块的代码, 实际上我们一直这样做, 直到此时, 但那是因为我们的应用程序已经很简单了, 然而当代码库变得越来越大时, 开始有很多优势使用模块
  6. 第一个是模块成功, 真的很容易编写软件, 所以我们可以考虑模块作为小积木, 然后我们可以把它放在一起, 为了构建真正复杂的应用程序
  相机案例研究
    1. 我们拿这台数码相机。 你可以看到这个特定的相机 基本上由所有这些模块组成 我们可以在这里看到。 这正是我们编写软件的方式 也使用模块。 这些相机模块的另一大优势 是他们每个人都可以 完全隔离开发。 所以你可以让一名工程师来处理镜头 和另一个在屏幕上 甚至控制器模块上的另一个。 最好的部分是每个工程师 实际上可以在自己的模块上工作 甚至没有理解 其他工程师在做什么。 也没有理解 整个最终相机如何工作
  1. 隔离组件是使用模块的另一个巨大优势, 隔离组件本质上意味着每个模块可以单独开发, 无需开发人员考虑关于整个代码库, 他甚至不需要了解这一切, 这使它非常容易在更大的团队中协作
  2. 模块使它变得非常容易抽象或编码, 我们已经谈过了抽象是什么意思, 但基本上我们可以使用模块实现低级代码, 然后是其他模块, 这并不在乎关于这些低级细节, 可以导入这些抽象并使用它们
  3. 回到我们的相机, 屏幕模块, 例如, 不在乎关于低级实现细节控制器模块, 它可以简单地导入控制器, 但不知道它如何工作的并用它来控制相机的其他部分, 这就是抽象的力量
  4. 模块也自然领先到更有组织的代码库, 因为当我们分解我们的代码时, 分成单独的隔离和受阻模块, 这将自动组织我们的代码并使其更容易理解
  5. 因此, 仅此一项就是模块的巨大好处, 最后, 模块允许我们轻松重用项目中的相同代码, 甚至跨多个项目
  6. 例如, 如果我们使用模块实现几个数学函数在某个项目中, 如果我们需要相同的功能在下一项目中，我们需要做的就是复制那个模块到新项目
  7. 在我们这里的相机示例中, 这家公司现在可以使用完全相同的镜头或完全相同的屏幕在不同的相机型号中, 都是因为它们很好地抽象了这些组件成独立的可重用模块, 所以这就是模块的工作方式在一般软件设计中
  8. 现在让我们来看看模块, 特别是在JavaScript中, 从ES6开始, JavaScript有一个原生的内置模块系统, 现在我们确实有ES6之前的模块, 但我们必须自己实现它们或使用外部库, 所以ES6个模块是模块实际上存储在文件中的每一个文件都是一个模块
  9. 所以每个文件只有一个模块, 但现在你可能会想, 好吧, 脚本通常也是文件, 对吗？ 这当然是真的, 所以我们必要比较这两种类型的文件, 为了理解实际上存在巨大差异.

  老示脚本和现代ES6模块之间：
    1. 第一个区别是在模块中, 所有顶级变量被抓到模块, 所以基本上变量是私有的默认到模块, 并且外部模块可以访问的唯一方式, 模块内部的值是通过导出该值, 正如我们在上一张幻灯片中学到的那样
    2. 如果我们不出口, 那么外面的人就看不到这个变量了, 另一方面, 现在脚本中, 所有顶级变量总是全球性的, 我向你展示了这个在map项目中, 还记得吗？ 这可能会导致问题, 像全局命名空间污染, 多个脚本尝试声明变量的地方, 同名然后这些变量发生冲突
    3. 所以私有变量是这个问题的解决方案, 这就是ES6模块这样实现它的原因, 始终执行下一个ES模块在严格模式下, 而另一方面脚本默认以sloppy模式(正常模式，非严格模式)执行, 所以有了模块, 就不再需要了手动声明严格模式
    4. 此外, disc关键字始终未定义在顶层, 而脚本中它指向window对象, 对吗？
    5. 模块有什么特别之处是我们可以导出和导入值, 他们之间使用这个ES6导入和专家语法, 在常规脚本中, 导入和导出值是完全不可能的, 现在, 有一个非常重要的事情, 注意进出口, 他们只能发生的事实在顶层
    6. 如你所知, 无论在代码的什么地方你正在导入值, 就像导入语句将被移动到文件的顶部, 所以在实践中导入值始终是模块中发生的第一件事
    7. 现在为了将模块链接到HTML文件, 我们需要使用脚本标签类型属性设置为模块, 而不仅仅是一个简单的脚本标签(重点)
  关于下载模块文件本身
    1. 这总是自动发生以异步方式, 这对于加载的模块是正确的来自HTML以及模块通过导入加载的一个模块到另一个模块, 使用导入语法
    2. 另一方面, 现在常规脚本默认下载以堵塞同步的方式, 除非我们使用异步或脚本标签上的不同属性, 这是对ES6模块的一个很好概述, 但现在让我们深入挖掘一下并真正了解模块是如何实际上在幕后导入其他模块
      代码示例解析
        1. 从math.js模块中调用rend并显示来自愚蠢的js模块的死亡, 当一段代码被执行时, 第一步时解析该代码
        2. 请记住, 解析基本上意味着只需阅读代码, 但没有执行它, 这就是时刻其中进口吊装, 而实际上, 导入模块的全过程发生在主模块中的代码之前实际执行
        3. 在这个例子中, index.js模块导入数学模块以同步方式, 这意味着只有在所有导入的模块都已经下载并执行, 主要的index.js模块最后也将被执行
        4. 现在这只时可能的, 因为顶级进口和出口, 那是因为如果我们只导出和导入值在任何需要执行的代码之外, 然后引擎可以直到解析阶段的所有导入和导出
        5. 所以当代码还在被读取时, 在被处决之前, 现在, 如果我们被允许导入一个模块在函数内部, 那么该功能将首先必须在导入代码发生之前执行, 所以在那种情况下, 无法以同步方式导入模块, 所以导入模块必须先执行
          为什么我们想要模块以同步方式加载？(重点)
            1. 这是最简单的方法, 我们可以在其中做事, 比如捆绑和死代码消除, 所以基本上删除代码, 这实际上甚至没有必要
            2. 相信我, 这在大型项目中非常重要, 拥有数百个模块并且包括第三方模块, 我们通常只想要一小块, 而不是整个模块
            3. 所以通过了解所有的依赖之间执行前的模块, 打包工具, 如webpack和Parcel然后可以将多个模块连接在一起并消除该代码, 所以基本上就是为什么我们只能导入和导出有任何需要执行的代码之外(重点)
            4. 就像一个函数或一个if块, 但现在让我们继续, 所以在解析过程之后, HIAS找出它需要导入哪些模块, 然后这些模块实际上被下载了从服务器
            5. 记住下载实际上发生了以异步方式, 这只是导入操作本身, 这是同步发生的, 然后在一个模块到达后, 它也被解析并且模块导出连接到index.js中的导入
            6. 例如math模块导出一个名为rend的函数, 然后这个出口被连接到index.js 模块中的租金导入, 这种联系其实是一种生活联系, 因此导出的值不会复制到导入中(重点)
            7. 相反, 导入基本上只是一个参考, 出口价值就像一个指针, 所以当值改变时在导出模块中, 那么相同的值也会改变在导入模块中
            8. 理解这一点很重要, 因为它时ES6模块独有的, 其他模块系统不是这样工作的, 但是JavaScript模块可以
            9. 所以你需要牢记这一点, 接下来， 执行导入模块中的代码。 有了这个导入过程 模块终于完成了。 所以现在，正如我已经说过的， 是时候导入模块了 也将被最终执行。 所以这个例子中的 index.js 

  // 模块是一个非常重要的部分 的软件开发。 所以在这次讲座中， 我们将更深入地讨论模块 并了解他们如何在幕后工作。 所以本质上，一个模块 是一段可重用的代码 封装了实现细节 我们项目的某个部分。 现在这听起来有点像一个函数 甚至一个班级， 但不同的是一个模块 通常是一个独立的文件。 现在情况并非总是如此， 但通常当我们想到一个模块时 我们想到了一个单独的文件。 所以当然一​​个模块总是包含一些代码 但它也可以有导入和导出。 所以对于出口，顾名思义， 我们可以从模块中导出值 例如，简单的值甚至整个函数。 以及我们从模块中导出的任何内容 称为公共 API。 所以这就像类 我们还可以公开一个公共 API 供其他代码使用。 现在，在模块的情况下， 这个公共API实际上被消耗了 通过将值导入模块。 所以就像我们可以导出值一样 在模块中，我们通常也可以导入值 来自其他模块。 以及我们从中导入的这些其他模块 然后称为依赖项 导入模块
  
  

*/
/* 模块概述
    1. 组合软件：模块是我们用来构建复杂应用程序的小构建块；
    2. 独立组件：模块可以独立开发，无需考虑整个代码库；
    3. 抽象代码：在模块中实现低级代码，并将这些抽象引入到其他模块中；
    4. 有组织的代码：模块自然会导致更有组织的代码库；
    5. 重用代码：模块允许我们轻松地重用相同的代码，甚至跨多个项目。
*/
/* 原生JavaScript(ES6)模块
    1. 存储在文件中的模块，每个文件只有一个模块。
    2. 导入和导出语法
                ES6 MODULE      SCRIPT
    顶级变量     作用域到模块     全球变量
    默认模式      严格模式     Sloopy正常、慵懒模式
    顶级this     undefined        window
    进出口     YES(需要发生在高层吊装！) NO
    HTML链接 <script type="module"> <script>
    文件下载        异步            同步
*/
/* ES6 模块时如何导入的
    执行前导入模块：
      1. 模块同步导入
      2. 可能要归功于顶级（“静态”）导入，它使导入在执行前已知
      3. 这使得捆绑和死代码消除成为可能

                      解析 index.js

      异步下载 math.js             异步下载dom.js
      将导入链接到 math.js 导出    将导入链接到 dom.js 导出
      执行 math.js                 执行 dom.js
                      执行 index.js
*/

/* 在ES6模块中导出和导入 */
/* 报错
  1. Uncaught SyntaxError: Cannot use import statement outside a module 未捕获的语法错误：无法在模块外使用导入语句
  2. 我们需要指定script的属性 type="module"
*/
/*
  1. 请记住所有导入语句, 基本上都被吊到了顶部, 这实际上也是我们编写它的方式, 所有文件顶部的所有导入语句, 注意模块都已严格模式执行
  2. 回到“购物车”模块, 定义一些变量, 我们只想说, const shippingCost = 10, 假设我们有一张空卡, 这就像一个数组, 所以现在是一个空数组, 现在模块内声明的变量, 就像这里的两个一样, 实际上是雕刻到这个模块, 所以基本上在一个模块内, 模块本身就像顶级范围
  3. 所以默认情况下, 这意味着所有顶级变量, 在这个变量中是私有的, 所以不同于传统的脚本, 这会将所有变量放在全球范围内, 模块中的变量是有范围的, 因此我们使用模块中的变量需要导出
    在ES模块中, 有两种类型的导出, 命名导出和默认导出, 而命名导入其实是最简单的方式, 从模块中导出一些东西, 因为我们要做的就是把出口在任何我们可能想要导出的的的东西之前(重点)
      命名导出：
          1. 请记住, export导出函数必须发生在顶级, 如果发生在函数内部将会报错(重点) Uncaught SyntaxError: Unexpected token 'export'
          2. 我们可以导出多个变量, export { totalPrice, totalQuantity }, 也可以修改导出和导入变量的名称, 比如 export {totalPrice, totalQuantity as tq}
          3. 通过对象的方式获取其他模块, import * as ShoppingCart from './shoppingCart.js';, 注意我们使用它需要以对象的方式 ShoppingCart.addToCart('bread', 5);(重点)
          4. 让我们考虑这个, 这里的这个模块(shoppingCart)现在基本上是导出一个公共API, 就像一个Class, 所以就好像这个物体在这里, 是从类创建的对象, 现在有这些方法和属性, 实际上我们可以说父亲模块出口, 一种公共API, 因为其他一切当然都是私密的模块内部(重点)
      默认导出：
          1. export default function() {} 默认导出就是简单的导出一个值, 例如导出一个函数, 我们只需要导出这个值的本身, 根本不涉及任何名称, 我们只是导出这个值, 因此我们导入这个值时, 可以给它任何我们想要的名字
          2. 我们甚至可以混合所有import add, { addToCart, totalPrice as price, tq } from './shoppingCart.js';, 但是实践中, 我们通常从不混合同一个模块中的命名和默认导出, 所以这里并不是真正可取的
          3. 首选的风格是每个模块只使用一个默认专家, 然后像我们一样在这里导入它, 这就是为什么导入默认导出更容易
          4. 其实我也想证明你进口实际上是与出口的生命联系
    深入研究导入和导出函数的生活联系：(重点)
      1. 我们首先导出购物车卡中的 export const cart = []; 一个空数组, 然后调用我们默认导入函数中的方法, 最后打印cart变量, 它不在是一个空数组, 而是包含了所有执行方法push进入数组的对象
      2. 所以这证明了这里的导入, 事实上, 不仅仅是值的副本, 我们在这里出口的, 将简单的获取债务MTRA
      3. 这是一种生活联系, 当我们调用函数时, 我们另一个模块中调用的, 我们不断将对象推送到该数组, 所以当然这里, 我们看到控制台中操作数组, 因为我们把购物车锁在这里, 所以它们实际上，基本上是在幕后完全相同的对象
      4. 进口不是出口的副本, 相反, 它们就像一个实时连接, 这意味着我指向同一个地方,
      5. 如果它是副本, 我们不会在数组中得到任何东西, 请记住这一点, 当我们编写自己的程序时, 因为这当然会导致错误, 如果你不知道你在做什么, 如果你不知道它的实际运作方式
      6. 这是非常重要的基础, 我们如何组织现代JavaScript代码库, 请一定复习此讲座
*/

/* 模块模式 */
/*
  1. 模块模式的主要目标是封装功能, 拥有私有数据, 并公开一个公共API, 以及实现这一切的最佳方式, 是通过简单地使用一个函数, 因为函数默认为我们提供私有数据, 并允许我们返回值, 这可以称为我们公共API
  2. IIFE是一个立即调用的函数表达式, 这样我们就不必单独调用它, 我们也可以确保它只被调用一次, 对吧？ 我们包装并创建一个IIFE, 这个功能很重要, 只创建一次, 因为这个函数的目标不是通过多次运行来重用代码, 此功能的唯一目的是创建一个新的范围并只返回一次数据
    你是否完全了解它的工作原理和原因?(在于script.js文件中的闭包函数分析模块运作方式 ------- 非常重要)
      1. 我们如何可以在此处访问购物车变量, 甚至能够操纵它, 所以我们看到它确实发生了变化, 所以我们如何才能做到这一点, 即使这个IIFE在这里, 所以这个函数早就回来了, 对吧? , 所以这个函数, 当然只执行了一次, 然后它做的就是返回这个对象, 并将其分配给这个变量(重点中的重点)
      2. 我们可以使用所有这些方法属性, 并操作数据, 在这个函数里, 这是返回对象的函数, 以及所有这一切如何运作的答案
      3. 关闭, 闭包允许一个函数访问到所有存在的变量在它的诞生地, 基本上这是我当时使用的一个很好的类比, 当我们第一次谈到闭包时, 我认为这是一种很好的可视化方式, 在这种情况下它是如何工作的
      4. 添加购物车功能是在return{}中创建的, 所以这个功能在这里, 是这个功能的发源地, 因此这个函数永远不会失去连接, 到它的发源地, 这就是这里的功能
      5. 所以那个出生地, 可以说, 这就是所有这些范围, 其中当然包含购物车, 因此, 添加到购物车功能在这里, 仍然可以访问该购物车变量, 那是在函数中, 好吗?
      6. 不是因为cart变量也在这个对象中, 所以不相关, 因为我们没有用this.cart对吧, 我么只是使用购物车, 所以在这里我们也可以登录, 这个模块确实是私有的, 所以一些东西不会出现在这个导出的对象中, 所以假设运输成本

    模块模式的优势:
      现在, 问题是如果我们想要每个文件一个模块, 就像我们使用ES6模块一样, 那么我们将不得不创建不同的脚本, 并将它们全部链接到HTML文件中, 然后回产生一些问题, 就像我们必须小心订单一样, 我们在HTML中声明它们, 我们将拥有所有变量, 生活在全球范围内, 最后, 我们无法将它们捆绑在一起, 使用模块打包器, 使用模块打包器非常重要, 在现代JavaScript中, 所以我们刚刚学到的模块模式确实工作的很好, 但它有一些局限性
*/

/* CommonJS 模块 */
/*
  1. 除了原生 ES 模块和模块模式 还有其他模块系统已经使用的过去通过 JavaScript。 但同样它们不是原生 JavaScript。 所以他们依赖于一些外部实现。 两个例子是： AMD 模块 和 CommonJS 模块。 事实上CommonJS 模块值得一看。
  2. CommonJS 模块对我们很重要, 因为它们已经在 node.js 中使用过, 几乎所有的存在, 所以就在最近, ES模块实际上已经实现, 在node.js中, node.js是一种方式在web服务器上运行JavaScript, 在浏览器之外, 现在这个重大的后果, 几乎所有的模块在npm存储库中, 所有这些模块, 我们可以在我们自己的代码中使用
    仍然使用CommonJS模块系统的原因是?
      1. npm最初是仅用于节点,正如他们所说, 使用的commonJS, 直到后来npm称为标准存储库, 对于整个JavaScript世界, 所以现在我们基本上被卡住了, 使用CommonJS, 因此, 你可能会看到, 很多CommonJS仍然存在
      2. 
    CommonJS是什么?
      1. 早先Node.js开发过程中它的作者发现在js中并没有像其他后端语言一样有包引入和模块系统的机制。这就意味着js的所有变量函数都在全局中定义。
      2. 这样不但会污染全局变量更会导致暴露函数内部细节等问题, CommonJS组织也意识到了同样的问题于是 CommonJS组织创造了一套js模块系统的规范。我们现在所说的CommonJS指的就是这个规范
  3.export.xxx 进而无论我们想出口到那里。 现在当然 这在浏览器中不起作用 但它可以在 Node.js 中工作。 所以这个导出关键字在这里 基本上是一个对象 再说一遍这里当然没有定义 在我们的代码中 也不在浏览器中。 但是在 Node.js中这是一个重要的对象使用的
  4. 实际上到 ES 模块 但从这里开始 我们将调用一个 require(要求) 函数. 所以就像这样, 所以再次要求当然没有定义, 在我们的浏览器环境中, 但它是在 Node.js 中定义的因为这是一部分 CommonJS 规范
  5. 这就是我要向你展示的全部内容尽管这当然是只是划伤表面. 但我想在这里做的一切只是让你知道有不同的模块系统还有那个 CommonJS 尤为重要在JavaScript的世界里
    CommonJS规范：
      1. 在ES6之前, ECMAScript并没有提供代码组织的方式, 那时候通常是基于IIFE来实现“模块化”, 伴随着JavaScript在前端大规模的应用, 以及服务端JavaScript的推动, 原先浏览器的模块规范不利于大规模应用, 于是早期便有了CommonJS规范, 其目标是为了定义模块, 提供通用的模块组织方式

      Module-ES和CommonJS的区别：
        https://segmentfault.com/a/1190000039395423
        模块化就是将变量和函数 放入不同的文件中
        模块的作用域是私有的 内部定义的代码只能在当前文件中使用
        外部使用那么需要将此模块暴露出去
        模块化的意义减少全局变量,避免变量名和函数命名冲突
        提高代码的复用性和维护性
        区别
        commonJS对模块依赖解决是“动态的”，ES6 Module是静态的
        commonjs模块输出的是值的浅拷贝，ES6模块输出的是值的引用 (cmmonjs模块输出后被改变，其引用模块不会改变，而ES6模块会改变)。
        commonJS这个“动态的”指的是模块依赖关系的建立发生在代码运行阶段。(重点)
        ES6这个“静态的”指的是模块依赖关系建立发生在代码编译阶段。(重点)
        webpack的tree-shaking只能作用于ES6模块，就是因为ES6模块在编译时就能确定依赖

        CommonJS规范，每个模块内部有两个变量可以使用 require 和 module

        require 用来加载某个模块
        module 代表当前模块，是一个对象，保存了当前模块的信息。exports 是 module 上的一个属性, 保存了当前模块要导出的接口或者变量, 使用 require 加载的某个模块获取到的值就是那个模块使用 exports 导出的值
        module.exports对象会作为require函数的返回值被加载. require的模块路径可以动态指定，支持传入一个表达式，也可以通过if语句判断是否加载某个模块。因此在CommonJS模块被执行前，并不能明确依赖关系，模块的导入导出发生在代码运行时。

        Node.js中的CommonJS规范，每个模块都有一个exports私有变量，exports指向module.exports
        exports 是模块内的私有局部变量，它只是指向了 module.exports，所以直接对 exports 赋值是无效的，这样只是让 exports 不再指向module.exports了而已


        CommonJS包规范与NPM包管理
        https://segmentfault.com/a/1190000018888081
        1.NPM 实践了 CommonJS 包规范规范，帮助我们安装和管理依赖包，使得 Node 项目的第三方模块更加规范便捷，可以在 NPM 平台上找到所有共享的插件
  */

/****************** Web开发基础命令行 */
/* window常用命令
  \ 下一级
  ..\ 上一级
  dir (打开根目录)
  cls  (清除命令行)
  cd. > 文件名.后缀 => (创建文件)
  del 文件名 => (删除文件)
  type 文件名 => (打开文件)
  md(mkdir) 文件名 => (创建文件夹) 
  rd(rmdir) 文件名 => (删除文件夹)
  rd /s/y 文件名 => (删除目录 /s 删除 /y 禁止询问是否删除)
  copy 路径\文件名 路径\文件名 => (复制文件)
  move 路径\文件名 路径\文件名 => (移动文件)
  move 路径\*后缀名 路径 => (移动同类型全部文件)
  ren(reName) 路径\文件名 更改文件名 => (更改文件名)
  rm -R 文件名 => (window删除文件夹下所有文件 mac删除整个文件夹)


  1. ls 打开根目录
  2. touch 创建文件
  3. clear 清除命令行
  4. mkdir 文件名 => 创建文件夹
  5. rmdir 文件名 => 删除文件夹(只适用于空目录)
  6. rm -R 文件名 => window删除文件夹下所有文件 mac删除整个文件夹
  7. rm 删除文件
  8. mv 文件名称 ../(上一级目录) 移动文件
*/

/****************** NPM介绍 */
/*
  1. 代表节点包管理器, 它即是我们电脑的软件和一个包存储库,
  为什么我们实际上需要一种管理包的方法或我们项目中的依赖项？
    1. 过去我们常常将外部库直接包含在我们的HTML中, 所以, 基本上使用脚本标签, 然后将暴露一个全局变量, 我们可以使用, 实际上就是这样
    2. 基本上使用一个脚本标签并在之前或自己的脚本之前完成, 这样我们自己的脚本就可以使用全局变量, 小项目中这没有问题, 但在庞大的项目中这将无法管理
    3. 首先加载HTML没有多大意义, 所有的JavaScript很乱, 有的时候我们实际上会下载一个库文件直接到我们的电脑, 例如jQuery javaScript文件, 但是每当我们有新版本出现时, 我们将不得不手动访问该站点, 下载新版本, 手动更改我们文件系统中的文件
    4. NPM之前, 根本没有包含所有包的单个存储库, 所以这让事情变得更糟糕更困难, 手动下载库并管理他们在我们的电脑上
  通过npm import cloneDeep from './node_modules/lodash-es/cloneDeep.js'; 指定路径非常不切实际

*/

/****************** 打包 Parcel 和 NPM 脚本 */
/* 
  1. npm i parcel --save-dev 安装依赖到代码中(再json的开发依赖中)
  2. npx 这基本上是一个内置于NPM的应用程序, 细节不重要, 重要的是我们可以简单的使用npx运行与我们之前相同的命令, 我们传递给parcel的选项, 基本就是这个切入口, 所以入口点是index.html
  3. 因为那是我们包含script.js的地方, 所以基本上是我们想要捆绑的文件, 所以我们script.js文件中, 我们目前包括这个来自Lodash的cloneDeep深度模块
    将js和依赖捆绑在一起：
      1. 我们使用parcel的目标, 就是将三个模块捆绑在一起, 所以script.js和shoppingCart.js和这个cloneDeep一起, 先在让我们实际尝试一下(npx parcel index.html)
      2. 并在幕后施展魔法但现在它实际上完成了. 所以一个包裹实际上也开始了此URL上的新开发服务器. 所以让我们点击它, 所以你会看到它在这里打开了一个新标签. 所以基本上除了捆绑, 它也与我们的实时服务器完成相同的工作. 所以请记住我们启动了这个开发服务器使用实时服务器包(重点)
      3. parcel的作用是它基本上简单地创建了一个脚本, 所以我们实际上不在使用模块, 但我们又回到使用常规脚本了, 这很重要, 因为模块在旧浏览器中不起作用(因此可以删除掉脚本标签的类型)(重点)
      4. 运行parcel发现目录下多了一个dist文件(类似webpack构建了一个web服务器并包含文件使用), 打开script.js文件我们可以看到parcel做了很多事情, 我们可以找到cloneDeep函数, 但实际上我们还没有删除没用的捆绑
    更改热模式：
      1. if (module.hot) { module.hot.accept(); }
      2. 我们可以编写热模式(Parcel and hot module replacement)更换, 这是惊人的, 我们改变一些东西时, 将不会重新加载页面其他部分, 用于维护我们页面上的状态, 每当我们测试某东西时, 这在过去曾经是一个很烦人的事情, 例如我们的Bankist应用程序
    更简洁的导入第三方依赖：
      1. import cloneDeep from './node_modules/lodash-es/cloneDeep.js'; 每次手动调用捆绑完整路径十分麻烦, 因此parcel允许我们直接 import cloneDeep from lodash 包含这个库, 所以包裹会自动找到这个模块的路径, 并且会像这样简单地导入它, 无需我们手动捆绑到那里的整个路径
      2. 我们使用lodash并不是lodash-es也可以搜索依赖为什么？因为这会询问packpage.json文件, 我们没有安装lodash因此还是查询lodash-es依赖
      3. 这适用于各种资产, 即使是HTML、CSS、SASS文件, 甚至图像, 当然还有各种模块, 所以不仅是ESX模块, 这也适用于CommonJS模块
      4. parcel确实可以工作以及所有CommonJS模块, 我们可以简单地使用NPM上可以用的所有模块, 并且仍然使用这种较旧的模块格式
    全局安装：
      1. npm i xx -g 全局安装依赖, 这实际上是方式, 我们之前安装了实时服务器包, 正因如此, 我们就可以简单的使用实时服务器在我们计算机上的每个目录中
      2. 所以差别还是很大, 在全局和本地安装的包之间, 尤其是这些工具, 例如Parcel或实时服务器, 是我们可以使用的全局工具, 直接在命令行, 没有NPM脚本的中间步骤
      3. 这些工具中的大多数实际上建议开发人员始终在本地安装工具, 这些他们就可以始终保持最新版本, 所以通常我们也遵循这种方法.
    依赖类型：
      1. lodash => CommonJS lodash-es => ESX模块 
    
所以让我们保持原样，再次保存它。 也许你已经注意到这个购物车就在这里 不断成长，成长，成长。 所以如果我们看看这个， 你看到我们正在添加这三个产品 再三，一而再再而三。 其原因是热模块更换。 因此，每当我们在此处重新加载页面时，都会保持状态。 这正是我们现在可以在这里观察到的。 好的。 所以如果我们再次保存它，那么我们将有 15 因为我们只是将新对象添加到这个对象中 基本上，在页面重新加载时会持续存在。 所以这适用于所有状态， 再说一次，这将是非常非常有帮助的。
*/

/*
  window10使用cmd npm依赖需要以管理员的方式下进行操作！
  npm i xx (正常安装)
  npx i xx (内置npx应用程序安装)
  sudo i xx (更多权限安装--询问密码)
  npm i xx@x.xx.x (安装指定版本号)
  $ npm 查看所有命令
  $ npm init 可以快速生成一个package.json 文件
  npm cache verify
*/
/****************** 配置 Babel(预设) 和 Polyfilling(填充) */

/*
  1. 在引入新的ES6标准之后, 有很多电脑比较卡, 用的xp、win7系统不能升级他们旧的IE浏览器
  2. 我们希望我们的应用程序适合所有人, 因此我们需要牢记每个人, 好消息是, 该parcel实际上会自动使用Babel转译或编码
  3. 如果愿意, 我们可以对Babel进行很多配置, 列如准确定义, 应该支持哪些浏览器, 但与往常一样, 这是一项繁重的工作, 所以我们不希望那样, 而paecel使对我们来说一些非常好的默认决定。因此，我们将主要使用这些默认值
  4. Babel会自动选择应该编译哪些JavaScript特性, 基于浏览器支持, 这些都是自动发生的, 开箱即用, Babel将转换所有功能, 所以只有几乎不再使用的浏览器, 市场份额小于0.25%不会得到支持, 通过此处使用此预设进行转译
    为什么一些ES的语句没有被编译？
      1. find和promise不会转换为ES5, 因为浏览器理我们的ES6
      2. 语法容易转换, 所以容易编译, 这根本不可能, 只有语法容易转换, 所以容易编译, 然而, 并没有失去所有希望, 所以对于这些附加功能, 例如承诺所有数组方法, 就像发现的东西, 还有一堆其他的东西, 我们可以对他们进行polyfill, 这就是为什么一直说转译, 我们必须对他们进行polyfill
  5. ( npm i core-js )现在Babel用来做polyfiling, 不久前开箱即用, 最近他们开始简单地推荐另一个图书馆, 所以我们现在也必须手动导入数据, 所以导入Core-js, 这是库的名称, 然后我们通常只想导入一部分
  6. npm i regenerator-runtime 这称为 NPM 安装再生器运行时。 所以再生器。这是正确的。 所以让我们看看，让我们已经把它包括在这里。 所以我们需要导入，所以像这样的 regenerator-runtime/runtime。
  7. 所以这里是用于 polyfill async 函数。 再一次，它可能看起来有点混乱 我们必须做所有这些，但是，别担心。 这只是一个你必须遵循的食谱。 好的。通常你会放 这些导入就在您文件的顶部 但在这种情况下，我们可以把它们留在这里 因为无论如何他们都会被托管，对吗？ 还要记住，所有这些都可能会改变

  babel 重要组成部分
    @babel/core 基础框架，配合 presets 和 plugins 进行转换代码，并提供了核心 API
    @babel/polyfill 模块包括 core-js ( 提供 ES6 的各种 polyfill ) 和 regenerator runtime ( 提供generator、async、await的 polyfill ) 来模拟完整的 ES2015+ 环境。（Babel 7.4.0 起已经废弃 @babel/polyfill，直接使用 core-js/stable 和 regenerator-runtime/runtime 替代）
    @babel/cli babel 提供的命令行工具，可以在命令行执行代码转换

    // 核心概念
    1. plugins: babel 基于插件进行转码，每个插件转换不同的语法或者特征，如 @babel/plugin-transform-arrow-functions 负责箭头函数的转换、@babel/pugin-transform-classes 负责转换 class 语法，每个插件需要配置在 .babelrc 的 pugins 属性中。

    2. presets: 如果单独引入插件会非常麻烦，presets 负责把一些相关的插件打包在一起，当设置为某一个预设的时候，里面就会包含相关的插件，可以简化 babel 配置。
    .babelrc: babel的配置文件，主要配置为 presets 和 plugins，详细信息参考官网关于 babel 的配置讲解
  */

/*
  可读代码
  编写代码以便其他人可以理解它
  写代码，让你1年看懂
  避免过于“聪明”和过于复杂的解决方案
  使用描述性变量名称：它们包含什么
  使用描述性函数名称：它们的作用

  一般的
  使用 DRY 原则（重构你的代码）
  不要污染全局命名空间，而是封装
  不要使用var
  使用强类型检查（=== 和 !==）

  职能 function
  一般来说，函数应该只做一件事
  不要使用超过3个函数参数
  尽可能使用默认参数
  通常，返回与接收到的数据类型相同的数据类型
  使用箭头函数使代码更具可读性

  0OP
  使用 ES6 类
  封装数据，不要在类外对其进行变异
  实现方法链
  不要使用箭头函数作为方法（在常规对象中）

  避免嵌套代码
  使用提前返回（保护条款）
  使用三元（条件）或逻辑运算符而不是 if
  使用多个 if 而不是 if/else-if
  避免 for 循环，改用数组方法
  避免基于回调的异步 API

  异步代码
  使用异步/等待的承诺以获得最佳可读性
  只要有可能，并行运行承诺 (Promise.all)
  处理错误和承诺拒绝
*/
/****************** 让我们修复一些错误的代码：第 1 部分(clean.js) */

/****************** 声明式和函数式 JavaScript 原则 */
/*
  1. 实施了一些干净和现代JavaScript实践, 不过目前有一个大趋势, 并转向称为声明性代码的东西和JavaScript中的函数式编程
  2. 所以有两种根本不同的方式, 在编程中编写代码, 我们也称之为范式, 是命令式代码和声明代码
    命令式代码：
      现在, 每当我们编写命令式代码时, 我们基本上需要向电脑解释如何做某事, 基本上, 我们需要解释每一步计算机需要遵循以达到一定的效果
        烤蛋糕实例解析：
          我们会准确地告诉这个人一步一步的食谱他们必须遵循才能烤出那个蛋糕
    声明式编程(函数式编程)：
      程序员只告诉计算机要做什么, 因此当我们编写声明性代码时, 我们简单地描述了计算机应该实现的方式一定的结果
      烤蛋糕实例解析：
        简单地向那个人描述那个蛋糕, 这个人必须上来一步一步的食谱

    函数副作用概念理解：(有图)(重点)
    1. 理解这一点非常重要， 因为越来越多的是现代 JavaScript 代码 实际上是写的
    2. 基本上是一个声明式范式，这是基于编写软件的想法，简单地通过组合多个所谓的纯函数，同时避免副作用和变异数据。实际上，函数式编程 并编写声明性代码，现在已经基本成为现代写代码的方式 在 JavaScript 世界中。因此，您将到处看到声明性和功能性代码。事实上，我们甚至一直在使用它，但在不知道这种风格的情况下被称为声明性和功能性，好吧。
      但让我们快速回到定义函数式编程，说说有哪些副作用和纯函数。
        1. 所以，副作用基本上只是一个修改 函数之外的任何数据。 因此，例如，改变任何外部变量 对函数造成副作用。 所以基本上，任何超出范围的变量的功能，好吗？ 现在，数据不仅仅指变量， 例如，将内容记录到控制台， 或者在 DOM 中改变一些东西， 也在引起副作用。 接下来是一个纯函数， 是一个没有副作用的函数。 所以，基本上是一个不会变异的函数 任何外部变量，而且也不依赖 在任何外部变量上。 所以基本上，如果我们给一个纯函数相同的输入， 它总是会返回相同的输出 再一次，那是因为它不依赖 在任何外部变量上， 它也不操纵它们。 最后，如果我们再看一下这里的定义， 我们还看到函数式编程 是关于避免变异数据， 我们通过使用称为不变性的东西来做到这一点。 所以，在函数式编程状态， 这也意味着基本上数据永远不会被修改。 所以，假设我们有一些应用程序， 我们有一个对象来跟踪所有数据 我们在应用程序中需要的。 所以我们通常称之为状态， 再一次，在函数式编程中， 该状态永远不会被修改。 相反，我们要做的是复制那个对象， 所以那个状态，然后就是那个副本发生了变异， 然后可以返回， 但是从不触及原始状态，好吗？ 所以，这就是状态不可变的意思， 不变性的最大好处是， 它使跟踪变得更加容易 数据如何流经我们的整个应用程序。 所以最终，这将使我们能够编写更好的代码 更少的错误，以及更易读的代码， 总体而言，这是整个目标 首先使用函数式编程。 现在，我告诉你这一切， 不是为了让你转身 成为一个函数式程序员， 因为那实际上是一项非常艰巨的任务，因为那实际上是一项非常艰巨的任务， 因为这真的只是一个非常高级的介绍 函数式编程究竟是什么。 但在表面背后， 函数式编程是一个巨大的范式， 这在实践中真的很难实施。 但你知道，这仍然很重要， 其中一些原则，例如副作用， 纯函数和不变性， 因为很多流行的图书馆， 如 React 或 Redux，实际上是构建的 围绕所有这些原则。 例如，在 React 中， 状态也是完全不可变的， 所以如果你想学习 React 之类的东西， 你需要了解这些概念 以便正确使用。 但是，一些原理，例如纯函数， 或副作用，实际上可以更容易实现 进入我们自己的代码。 所以，我想说的是， 我们实际上可以混合使用命令式和声明式编程 在我们自己的代码中，我们不必 100% 声明。 或者换句话说，我们不必100%朝这个方向走 使我们的代码完全正常运行。 再一次，我们已经可以开始使用， 一些函数式编程技术 在我们自己的代码库中。 因此，例如，您可以尝试避免数据突变 尽可能经常地。 当然，这并不总是可能的， 但这也不是真正必要的。 所以这些主要并且只是建议， 但这仍然会创造更多的可读性 和整体更好更干净的代码。 所以，你可以做的另一件事就是总是喜欢， 不产生的内置方法或函数 副作用超过那些， 这对于数据转换非常重要。 所以每当你想这样做时， 您应该使用 Map、Filter 和 Reduce 等方法。 所以，这是功能性和现代的方式 进行数据转换，很多时候， 这其实是很多人的第一次接触， 用函数式编程。 因此，实际上存在 Map、Filter 和 Reduce 在所有函数式编程语言中， 它们对于实现功能代码非常重要 在我们的代码中加入更多的声明性代码。 最后，你也可以尽量避免副作用 到您自己编写的函数中。 再说一次，这当然并不总是可能的， 而且并不总是必要的。 所以，我们永远无法避免所有的副作用 在应用程序中，因为当然，在某些时候， 应用程序需要做一些事情。 所以，它需要在 DOM 上显示一些东西， 或将某些内容记录到控制台， 或者真的产生一些副作用，好吗？ 但是你还是可以试着想想这个， 并开始考虑副作用 更多到你自己的代码中。 现在结束，让我们回到声明式语法， 因为函数式编程只是使用的一部分 并编写声明性代码。 因此，为了编写更具声明性的代码， 你应该使用数组和对象解构 只要有可能。 您还应该使用扩展运算符， 三元运算符，以及模板文字 只要有可能，因为如果你考虑一下， 那么这四种写代码的方式， 实际上使代码更具声明性。 所以，这些操作符更多的是告诉代码 要做什么，而不是确切的步骤 它应该采取，对吧？ 这同样适用于所有这四种语法。 好的，让我们现在继续工作

*/
/* 命令式VS声明性代码(有图)
    两种不同的代码编写方式(范式)
      命令式：
        1. 程序员解释“如何做事”
        2. 我们解释了计算机为实现结果而必须遵循的每一步
        3. 示例：蛋糕的分步食谱
      声明式：
        1. 程序员告诉“做什么”
        2. 我们简单地描述了计算机应该如何实现结果
        3. HOW（分步说明）被抽象掉 示例：蛋糕的描述
*/

/* 命令式代码
  1. 一种纯粹命令式的写法。所以，在这里我们一步一步告诉计算机，创建一个空数组来创建一个计数器从零开始，然后增加该计数器直到我们达到原始数组的长度，然后如何准确存储新结果在数组的每个新位置
  2. 有很多步骤 我们真的把电脑给了这里， 为了让我们达到结果 将 R 数组加倍
*/
const arr = [2, 4, 6, 8];
const doubled = [];
for (let i = 0; i < arr.length; i++) doubled[i] = arr[i] * 2;

/* 声明式代码 
    1. 我们有 R 数组，然后我们简单地告诉 JavaScript， 它应该将 R 数组中的值映射到一个新数组， 并且这些值中的每一个都应乘以 2
    2. 我们所做的只是描述方式计算机应该达到的结果我们正在寻找的。我们只是告诉它做什么，在这种情况下，是简单地将原始数组映射到新数组上并将所有元素加倍
    3. 这些超级详细的步骤我们在左侧，就像创建一个空数组并初始化一个计数器，所有这些步骤都被抽象掉了，因为我们并不真正关心他们
*/
const arr = [2, 4, 6, 8];
const doubled = arr.map(n => n * 2);

/* 函数式编程原理(有图)
  声明式编程范式
    1. 基于结合许多纯函数编写软件的思想，避免副作用和变异数据
    2. 副作用：修改（变异）函数外的任何数据（变异外部变量、记录到控制台、写入 DOM 等）
    3. 纯函数：没有副作用的函数。 不依赖于外部变量。 给定相同的输入，总是返回相同的输出。
    4. 不变性。 状态（数据）永远不会被修改！ 相反，状态被复制，副本被改变并返回。(不仅适用于对象和数组, 也适用于常规的变量)
    5. 列子：React Redux
  函数式编程技术
    1. 尽量避免数据突变
    2. 使用不会产生副作用的内置方法使用以下方法进行数据转换
    3. as .map()、.filter() 和 .reduce()
    4. 尽量避免函数中的副作用：这当然总是可能的！
  声明性语法
    1. 使用数组和对象解构使用扩展运算符(...)
    2. 使用三元（条件）运算符使用模板文字
*/

/* 课外概念
  什么是函数的副作用——理解js编程中函数的副作用:
    定义：函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变
    1. 函数副作用是指当调用函数时, 除了返回函数值之外, 还对主调用函数产生附加的影响, 副作用的函数不仅仅只是返回了一个值, 而且还做了其他的事情：比如：(重点)
      a) 修改了一个变量
      b) 直接修改数据解构
      c) 设置一个对象的成员
      d) 抛出一个异常或以一个错误终止
      e) 打印到终端或读取用户输入
      f) 读取或写入一个文件
      g) 在屏幕上画图
    2. 函数的副作用会给程序设计带来不必要的麻烦, 给程序带来十分难以查找的错误, 并降低程序的可读性, 严格的函数式语言要求函数必须无副作用
  非纯函数
    3. 与之相反, 隐式的意思是, 函数通过参数和返回值以外的渠道, 和外界进行数据交换, 比如读取/修改全局变量, 都叫做以隐式的方式和外界进行数据交换
  引用透明
    4. 引用透明的概念与函数的副作用相关, 且受其影响, 如果程序中两个相同值得表达式能在该程序的任何地方相互替换, 而不影响程序的动作, 那么该程序就具有引用透明性, 它的优点式比非引用透明的语言的语义更容易理解, 不那么晦涩, 纯函数式语言没有变量, 所以他们都具有引用透明性

  函数式编程：(重点)
    1. 相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程 
    2. 简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值
  函数式编程优缺点：
    优点：
      1. 更好的管理状态：因为它的宗旨是无状态, 或者说更少的状态, 能最大化的减少这些未知、优化代码、减少出错情况
      2. 更简单的复用：固定输入 => 固定输出, 没有其他外部变量影响, 并且无副作用, 这样代码复用时, 完全不需要考虑它的内部实现和外部影响, 并且无副作用, 这样代码复用时, 完全不需要考虑它的内部实现和外部影响
      3. 更优雅的组合：往大了说, 网页是由各个组件组成的, 往小了说, 一个函数也可能是由多个小函数组成的, 更强的复用性, 带来更强大的组合性
      4. 隐形好处, 减少代码量, 提高维护性
    缺点：
      1. 性能：函数式编程相对于指令式编程, 性能绝对是一个短板, 因为它往往会对一个方法进行过度包装, 从而产生上下文切换的性能开销
      2. 资源占用：在js中为了实现对象状态的不可变, 往往会创建新的对象, 因此, 它对垃圾回收产生的压力远远超过其他编程方式
*/

/* 组合和柯里化的技术和React概念
  1. 我们会使用一种叫做组合的东西, 和称为柯里化的技术, 基本上这里创建这个操作链, 所以这里我们需要所有这些中间变量, 创建一个新的预算, 对吗？
  2. 所以称之为一旦将结果存储在一个新变量中, 然后下一次调用我们使用前一个变量, 然后下次调用我们使用前一个变量, 然后再下次通话中, 我们再次使用之前的变量, 所以这是一连串的附加费用, 最好总是自动将上一个结果用于下一个操作
  3. 在现实世界中, 大型功能应用程序, 我们会使用组合来创建一个函数, 然后将立即执行所有这些操作, 但这确实超出了本课程的范围, 因为那本生就是一个大世界, 所以这里我们只是试图实现其中一些技术和概念, 只是为了让您看到它如何工作以及它们的存在, 并且它们很重要,(重点)
  4. 一旦你开始使用其中一个框架, 就像React或Redux一样, 它们严重依赖于概念, 例如不变性和纯函数, 无论如何, 让我们现在继续我们的代码, 我们已经谈论了很多副作用和不变性和纯函数, 现在把注意力转向数据转换
*/
